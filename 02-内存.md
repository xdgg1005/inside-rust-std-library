# RUST 标准库内存模块代码分析

内存模块的代码路径举例如下 (以作者电脑上的路径):

```sh
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\alloc\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\ptr\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\mem\*.*
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\core\src\intrinsic.rs
%USER%\.rustup\toolchains\nightly-x86_64-pc-windows-msvc\lib\rustlib\src\rust\library\alloc\src\alloc.rs
```

RUST 最难以掌握特性之一是 RUST 的内存操作. RUST 与 C 相同, 需要对内存做彻底的控制, 即程序可以在代码中编写专属内存管理系统, 并将内存管理系统与语言类型相关联, 在内存块与语言类型之间做自如的转换. 对于当前现代语法的高级语言如 Java/Python/JS/Go, 内存管理是编译器的任务, 这就导致大部分程序员对于内存管理缺乏经验, 所以对 RUST 内存安全相关的所有权 / 生命周期等缺乏实践认知. 相对于 C, RUST 的现代语法及内存安全语法导致 RUST 的内存块与类型系统相互转换的细节非常复杂, 不容易被透彻理解. 本章将从标准库的内存模块的代码分析中给出 RUST 内存操作的本质. 对本章内容掌握了, RUST 语言的最难关便过了.

从内存角度考察一个变量, 则每个变量具备统一的内存参数, 这些参数是:

1. 变量的首地址, 是一个 `usize` 的数值
2. 变量类型占用的内存块大小
3. 变量类型内存字节对齐的基数
4. 变量类型中成员内存顺序

如果变量成员是复合类型, 可递归上面的四个参数.

RUST 认为变量类型成员顺序与编译优化不可分割, 因此, 变量成员内存顺序完全由编译器控制, 这与 C 不同, C 中变量类型成员的顺序是不能被编译器改动的. 这使得 C 变量的内存布局对程序员是完全可知的. 这种完全可知性导致了 C 语言在涉及类型内存布局的操作中会出现坏代码.

与 C 相同, RUST 具备将一块内存块直接转换成某一类型变量的能力. 这一能力是 RUST 系统级编程及高性能的一个基石. 但因为这个转换使得代码可以绕过编译器的类型系统检查, 造成了 BUG 也绕过了编译器的某些错误检查, 而这些错误很可能在系统运行很久之后才真正的出错, 造成排错的极高成本.

GC 类语言去掉了这一能力, 但也牺牲了性能, 且无法作为系统级语言. RUST 没有因噎废食, 在保留能力的同时给出这一能力明确的危险标识 `unsafe`, 加上整体的内存安全设计, 使得此类错误更易被发现, 更易被定位, 极大的降低了错误的数目及排错的成本.

`unsafe` 容易让初学 RUST 语言的程序员产生排斥感, 但 `unsafe` 实际上是 RUST 不可分割的部分, 一个好的 RUST 程序员绝不是不使用 `unsafe`, 而是能够准确的把握好 `unsafe` 使用的合适场合及合适范围, 必要的时候必须使用, 但绝不滥用.

掌握 RUST 的内存, 主要有如下几个部分:

1. 编译器提供的固有内存操作函数
2. 内存块与类型系统的结合点: 裸指针 `*const T`, `*mut T`
3. 裸指针的包装结构: `NonNull<T>`, `Unique<T>`
4. 未初始化内存块的处理: `MaybeUninit<T>`, `ManuallyDrop<T>`
5. 堆内存申请及释放

## 裸指针标准库代码分析

裸指针 `*const T`, `* mut T` 将内存和类型系统相连接, 裸指针代表了一个内存块, 指示了内存块首地址, 大小, 对齐等属性及后文提到的元数据, 但不保证这个内存块的有效性和安全性.

与 `*const T`, `* mut T` 不同, `&T` 和 `&mut T` 则保证内存块是安全和有效的, 即 `&T`, `&mut T` 满足内存块首地址内存对齐, 内存块已经完成了初始化. 在 RUST 中, `&T`, `&mut T` 是被绑定在某一内存块上, 只能用于读写这一内存块.

对于内存块更复杂的操作, 由 `*const T`, `*mut T` 负责, 主要有:

1. 将 `usize` 类型数值强制转换成裸指针类型, 以此数值为首地址的内存块被转换为相应的类型. 如果对这一转换后的内存块进行读写, 可能造成内存安全问题.
2. 在不同的裸指针类型之间进行强制转换, 实质上完成了裸指针指向的内存块的类型强转, 如果对这一转换后的内存块进行读写, 可能造成内存安全问题.
3. `*const u8` 作为堆内存申请的内存块绑定变量
4. 内存块置值操作, 如清零或置一个魔术值
5. 显式的内存块拷贝操作, 某些情况下, 内存块拷贝是必须的高性能方式.
6. 利用指针偏移计算获取新的内存块, 在数组及切片访问, 字符串, 协议字节填写, 文件缓存等都需要指针偏移计算.
7. 从外部的 C 函数接口对接的指针参数

RUST 的裸指针类型不象 C 语言的指针类型那样仅仅是一个地址值, 为满足实现内存安全的类型系统需求, 并兼顾内存使用效率和方便性, __RUST 的裸指针实质是一个较复杂的类型结构体__.

### 裸指针具体实现

`*const T`, `*mut T` 实质是个结构体, 由两个部分组成, 第一个部分是一个 __内存地址__, 第二个部分对这个内存地址的约束性描述 __元数据__.

```rust
// 从下面结构定义可以看到, 裸指针本质就是 PtrComponents<T>
pub(crate) union PtrRepr<T: ?Sized> {
    pub(crate) const_ptr: *const T,
    pub(crate) mut_ptr: *mut T,
    pub(crate) components: PtrComponents<T>,
}

pub(crate) struct PtrComponents<T: ?Sized> {
    // *const () 保证元数据部分是空
    pub(crate) data_address: *const (),
    // 不同类型指针的元数据
    pub(crate) metadata: <T as Pointee>::Metadata,
}

// 下面 Pointee 的定义展示一个 RUST 的编程技巧, 即 trait 可以只用
// 来定义关联类型, Pointee 即只用来指定 Metadata 的类型.
pub trait Pointee {
    /// The type for metadata in pointers and references to `Self`.
    type Metadata: Copy + Send + Sync + Ord + Hash + Unpin;
}

// 廋指针元数据是单元类型, 即是空
pub trait Thin = Pointee<Metadata = ()>;
```

元数据的规则:

* 对于固定大小类型的指针 (实现了 `Sized` Trait), RUST 定义为 __瘦指针__ (thin pointer), 元数据大小为 `0`, 类型为 `()`, 这里要注意, RUST 中数组也是固定大小的类型, 运行中对数组下标合法性的检测, 就是比较是否已经越过了数组的内存大小.
* 对于动态大小类型的指针 (DST 类型), RUST 定义为 __胖指针__ (fat pointer 或 wide pointer), 元数据为:

	- 对于结构类型, 如果最后一个成员是动态大小类型 (结构的其他成员不允许为动态大小类型), 则元数据为 __此动态大小类型的元数据__
	- 对于 `str` 类型, 元数据是 __按字节计算的长度值__, 元数据类型是 `usize`
	- 对于切片类型, 例如 `[T]` 类型, 元数据是 __数组元素的数目值__, 元数据类型是 `usize`
	- 对于 trait 对象, 例如 `dyn SomeTrait`, 元数据是 `DynMetadata<Self>` (后面代码解释, 例如: `DynMetadata<dyn SomeTrait>`)

随着 RUST 的发展, 有可能会根据需要引入新的元数据种类.

在标准库代码当中没有指针类型如何实现 `Pointee` Trait 的代码, 编译器针对每个类型自动的实现了 `Pointee`.

如下为 rust 编译器代码的一个摘录

```rust
pub fn ptr_metadata_ty(&'tcx self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {

	// FIXME: should this normalize?
	let tail = tcx.struct_tail_without_normalization(self);
	match tail.kind() {
		// Sized types
		ty::Infer(ty::IntVar(_) | ty::FloatVar(_))
		| ty::Uint(_)
		| ty::Int(_)
		| ty::Bool
		| ty::Float(_)
		| ty::FnDef(..)
		| ty::FnPtr(_)
		| ty::RawPtr(..)
		| ty::Char
		| ty::Ref(..)
		| ty::Generator(..)
		| ty::GeneratorWitness(..)
		| ty::Array(..)
		| ty::Closure(..)
		| ty::Never
		| ty::Error(_)
		| ty::Foreign(..)
		| ty::Adt(..)
		// 如果是固定类型, 元数据是单元类型 tcx.types.unit, 即为空
		| ty::Tuple(..) => tcx.types.unit,

		// 对于字符串和切片类型, 元数据为长度 tcx.types.usize, 是元素长度
		ty::Str | ty::Slice(_) => tcx.types.usize,
		// 对于 dyn Trait 类型, 元数据从具体的 DynMetadata 获取 *
		ty::Dynamic(..) => {
			let dyn_metadata = tcx.lang_items().dyn_metadata().unwrap();
			tcx.type_of(dyn_metadata).subst(tcx, &[tail.into()])
		},

		// 以下类型不应有元数据
		ty::Projection(_)
		| ty::Param(_)
		| ty::Opaque(..)
		| ty::Infer(ty::TyVar(_))
		| ty::Bound(..)
		| ty::Placeholder(..)
		| ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {
			bug!("`ptr_metadata_ty` applied to unexpected type: {:?}", tail)
		}
        }
}
```

以上代码中的中文注释比较清晰的说明了编译器对每一个类型 (或类型指针) 都实现了 `Pointee` 中元数据类型的获取.

对于 trait 对象的元数据的具体结构定义见如下代码:

```rust
// dyn trait 裸指针的元数据结构, 此元数据会被用于获取 trait 的方法
pub struct DynMetadata<Dyn: ?Sized> {
    // 在堆内存中的 VTTable 变量的引用, VTable 见后面的说明
    vtable_ptr: &'static VTable,
    // 标示结构对 Dyn 的所有权关系,
    // 其中 PhantomData 与具体变量的联系在初始化时由编译器自行推断完成,
    // 这里 PhantomData 主要对编译器提示做 Drop check 时注意本结构体会
    // 负责对 Dyn 类型变量做 drop.
    phantom: crate::marker::PhantomData<Dyn>,
}

// 此结构是实际的 trait 实现
struct VTable {
    //trait 对象的 drop 方法的指针
    drop_in_place: fn(*mut ()),
    //trait 对象的内存大小
    size_of: usize,
    //trait 对象的内存对齐
    align_of: usize,
    // 后继是 trait 对象的所有方法的指针数组
}
```

元数据类型相同的裸指针可以任意的转换, 例如: 可以有 * const [usize; 3] as * const[usize; 5] 这种语句.
元数据类型不同的裸指针之间不能转换, 例如; * const [usize; 3] as *const[usize] 这种语句无法通过编译器

### 裸指针的操作函数——intrinsic 模块内存相关固有函数

intrinsics 模块中的函数由编译器内置实现, 并提供给其他模块使用. 固有函数标准库没有代码, 所以对其主要是了解功能和如何使用, intrinsics 模块的内存函数一般不由库以外的代码直接调用, 而是由 mem 模块和 ptr 模块封装后再提供给其他模块.

内存申请及释放函数:
`intrinsics::forget<T:Sized?> (_:T)` , 代码中调用这个函数后, 在变量生命周期终止时, 编译器不会调用变量的 drop 函数.
`intrinsics::drop_in_place<T:Sized?>(to_drop: * mut T)` 在 forget 后, 如果仍然需要对变量调用 drop, 则在代码中显式调用此函数以触发对变量的 drop 调用.
`intrinsics::needs_drop<T>()->bool` , 判断 T 类型是否需要做 drop 操作, 实现了 Copy trait 的类型会返回 false

类型转换:
`intrinsics::transmute<T,U>(e:T)->U` , 对于内存布局相同的类型 T 和 U, 完成将类型 T 变量转换为类型 U 变量, 此时 T 的所有权将转换为 U 的所有权

指针偏移函数:
`intrinsics::offset<T>(dst: *const T, offset: usize)->* const T` , 相当于 C 的基于类型的指针加计算
`intrinsics::ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize` 相当于 C 的基于类型的指针减

内存块内容修改函数:
`intrinsics::copy<T>(src:*const T, dst: *mut T, count:usize)` , 内存拷贝, src 和 dst 内存可重叠, 类似 c 语言中的 memmove, 此时 dst 原有内存如果已经初始化, dst 原有变量的 drop 实质会不执行. src 的变量可能出现两次 drop, 因此调用此函数的代码需要处理这种情况.

`intrinsics::copy_no_overlapping<T>(src:*const T, dst: * mut T, count:usize)` , 内存拷贝, src 和 dst 内存不重叠, 内存安全问题同上

`intrinsics::write_bytes(dst: *mut T, val:u8, count:usize)` , C 语言的 memset 的 RUST 实现, 此时, 原内存如果已经初始化, 则因为编译器会继续对 dst 的内存块做 drop 调用, 有可能会 UB.

类型内存参数函数:
`intrinsics::size_of<T>()->usize` 类型内存空间字节数
`intrinsics::min_align_of<T>()->usize` 返回类型对齐字节数
`intrinsics::size_of_val<T>(_:*const T)->usize` 返回指针指向的变量内存空间字节数
`intrinsics::min_align_of_val<T>(_: * const T)->usize` 返回指针指向的变量对齐字节数

禁止优化的内存函数:
形如 `volatile_xxxx` 的函数是通知编译器不做内存优化的操作函数, 一般硬件相关操作需要禁止优化.
`intrinsics::volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize)` 内存拷贝

`intrinsics::volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize)` 功能类似 C 语言 memmove

`intrinsics::volatile_set_memory<T>(dst: *mut T, val: u8, count: usize)` 功能类似 C 语言 memset

`intrinsics::volatile_load<T>(src: *const T) -> T` 读取内存或寄存器, T 类型字节对齐到 2 的幂次

`intrinsics::volatile_store<T>(dst: *mut T, val: T)` 内存或寄存器写入, 字节对齐

`intrinsics::unaligned_volatile_load<T>(src: *const T) -> T` 字节非对齐

`intrinsics::unaligned_volatile_store<T>(dst: *mut T, val: T)` 字节非对齐

内存比较函数:
`intrinsics::raw_eq<T>(a: &T, b: &T) -> bool` 内存比较, 类似 C 语言 memcmp

`pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否判断, 相等返回 ture, 不等返回 false

`pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool` 判断两个指针是否不等, 不等返回 true

### 裸指针方法

RUST 针对 `*const T/*mut T` 的类型实现了若干方法:

```rust
impl <T:?Sized> * const T {
    ...
}
impl <T:?Sized> *mut T{
    ...
}
impl <T> *const [T] {
    ...
}
impl <T> *mut [T] {
    ...
}
```

对于裸指针, RUST 标准库包含了最基础的 `* const T/* mut T` , 以及在 `* const T/*mut T` 基础上特化的切片类型 [T] 的裸指针 `* const [T]/*mut [T]` .
标准库针对这两种类型实现了一些关联函数及方法. 这里一定注意, 所有针对 `* const T` 的方法在 `* const [T]` 上都是适用的.

以上有几点值得注意:
1. 可以针对原生类型实现方法 (实现 trait), 这体现了 RUST 类型系统的强大扩展性, 也是对函数式编程的强大支持
2. 针对泛型约束实现方法, 我们可以大致认为 `*const T/* mut T` 实质是一种泛型约束, `*const [T]/*mut [T]` 是更进一步的约束, 这使得 RUST 可以具备更好的数据抽象能力, 简化代码, 复用模块.

#### 裸指针的创建

直接从已经初始化的变量创建裸指针:

```rust
    &T as *const T;
    &mut T as * mut T;
```

直接用 usize 的数值创建裸指针:

```rust
    {
        let  a: usize = 0xf000000000000000;
        unsafe {a as * const i32};
    }
```

操作系统内核经常需要直接将一个地址数值转换为某一类型的裸指针

RUST 也提供了一些其他的裸指针创建关联函数:
`ptr::null<T>() -> *const T` 创建一个 0 值的 `*const T` , 实际上就是 `0 as *const T` , 用 null() 函数明显更符合程序员的习惯
`ptr::null_mut<T>()->*mut T` 除了类型以外, 其他同上

`ptr::invalid<T>(addr:usize)->*mut T` 将一个数值作为裸指针, 指明这是一个无效的裸指针.
`ptr::invalid_mut<T>(addr:usize)->*mut T` 将一个数值作为可变裸指针, 指明这是一个无效的指针.
以上两个函数通常是将指针变量用作他途以提高新能

`ptr::from_raw_parts<T: ?Sized>(data_address: *const (), metadata: <T as Pointee>::Metadata) -> *const T` 从内存地址和元数据创建裸指针

`ptr::from_raw_parts_mut<T: ?Sized>(data_address: *mut (), metadata: <T as Pointee>::Metadata) -> *mut T` 功能同上, 创建可变裸指针

RUST 裸指针类型转换时, 经常使用以上两个函数获得需要的指针类型.

切片类型的裸指针创建函数如下:
 `ptr::slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] `

`ptr::slice_from_raw_parts_mut<T>(data: *mut T, len: usize) -> *mut [T]` 由裸指针类型及切片长度获得切片类型裸指针, 调用代码应保证 data 事实上就是切片的裸指针地址.
由类型裸指针转换为切片类型裸指针最突出的应用之一是内存申请, 申请的内存返回 * const u8 的指针, 这个裸指针是没有包含内存大小的, 只有头地址, 因此需要将这个指针转换为 * const [u8], 将申请的内存大小包含入裸指针结构体中.

slice_from_raw_parts 代码如下:

```rust
pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {
    //data.cast() 将 * const T 转换为 *const()
    from_raw_parts(data.cast(), len)
}

pub const fn from_raw_parts<T: ?Sized>(
    data_address: *const (),
    metadata: <T as Pointee>::Metadata,
) -> *const T {
    // 由以下代码可以确认 * const T 实质就是 PtrRepr 类型结构体.
    unsafe {PtrRepr { components: PtrComponents { data_address, metadata} }.const_ptr }
}
```

#### 不属于方法的裸指针函数

`ptr::drop_in_place<T: ?Sized>(to_drop: *mut T)` 此函数是编译器实现的, 用于由程序代码人工释放所有权, 而不是交由 RUST 编译器处理. 此函数会引发 T 内部成员的系列 drop 调用.

`ptr::metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata ` 用来返回裸指针的元数据

`ptr::eq<T>(a: *const T, b: *const T)->bool` 比较指针, 此处需要注意, 地址比较不但是地址, 也比较元数据

ptr 模块的函数大部分逻辑都比较简单. 很多就是对 intrinsic 函数的直接调用.

#### 裸指针类型转换方法

裸指针类型之间的转换:
`*const T::cast<U>(self) -> *const U ` , 本质上就是一个 `*const T as *const U` . 利用 RUST 的类型推断, 此函数可以简化代码并支持链式调用.
`*mut T::cast<U>(self)->*mut U` 同上.

调用以上的函数要注意, 如果后继要把返回的指针转换成引用, 那必须保证 T 类型与 U 类型内存布局完全一致. 如果仅仅是将返回值做数值应用, 则此约束可以不遵守, cast 函数转换后的类型通常由编译器自行推断, 有时需要仔细分析.

裸指针与引用之间的类型转换:
`` `*const T::as_ref<'a>(self) -> Option<&'a T>` ` ` 将裸指针转换为引用, 因为 * const T 可能为零, 所有需要转换为 `  `Option<& 'a T>` ` 类型, 转换的安全性由程序员保证, 尤其注意满足 RUST 对引用的安全要求. 这里注意, ** 生命周期标注表明转换后的生命周期实际上与原变量的生命周期相独立 **. 因此, 生命周期的正确性将由调用代码保证. 如果没有标注, 则返回的引用的生命周期应该小于 self, 遵循函数参数及返回值的生命周期规则.
`` `*mut T::as_ref<` a>(self)->Option<& `a T>` ``   同上
`` `*mut T::as_mut<` a>(self)->Option<& `a mut T>` `` 同上, 但转化类型为 &mut T.

切片类型裸指针类型转换:
`ptr::*const [T]::as_ptr(self) -> *const T` 将切片类型的裸指针转换为切片成员类型的裸指针, 这个转换会导致指针的元数据丢失
`ptr::*mut [T]::as_mut_ptr(self) -> *mut T` 同上

#### 裸指针结构体属性相关方法:

 `ptr::*const T::to_raw_parts(self) -> (*const (), <T as super::Pointee>::Metadata)`

`ptr::*mut T::to_raw_parts(self)->(* const (), <T as super::Pointee>::Metadata)` 由裸指针获得地址及元数据
 `ptr::*const T::is_null(self)->bool`

`ptr::*mut T::is_null(self)->bool 此 ` 函数判断裸指针的地址值是否为 0

切片类型裸指针:
`ptr::*const [T]:: len(self) -> usize` 获取切片长度, 直接从裸指针的元数据获取长度
`ptr:: *mut [T]:: len(self) -> usize` 同上

#### 裸指针偏移计算相关方法

`ptr::*const T::offset(self, count:isize)->* const T` 得到偏移后的裸指针
`ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的 offset
`ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的 offset 值
`ptr::*mut T::offset(self, count:isize)->* mut T` 偏移后的裸指针
`ptr::*const T::wrapping_offset(self, count: isize) -> *const T` 考虑溢出绕回的 offset
`ptr::*const T::offset_from(self, origin: *const T) -> isize` 计算两个裸指针的 offset 值
以上两个方法基本上通过 intrinsic 的函数实现

 `ptr::*const T::add(self, count: usize) -> Self`

 `ptr::*const T::wraping_add(self, count: usize)->Self`

 `ptr::*const T::sub(self, count:usize) -> Self`

 `ptr::*const T::wrapping_sub(self, count:usize) -> Self`

 `ptr::*mut T::add(self, count: usize) -> Self`

 `ptr::*mut T::wraping_add(self, count: usize)->Self`

 `ptr::*mut T::sub(self, count:usize) -> Self`

 `ptr::*mut T::wrapping_sub(self, count:usize) -> Self`

以上是对 offset 函数的包装, 使之更符合语义习惯, 并便于理解

#### 裸指针直接赋值方法

```rust
    // 该方法用于仅给指针结构体的 address 部分赋值
    pub fn set_ptr_value(mut self, val: *const u8) -> Self {
        // 以下代码因为只修改 PtrComponent.address, 所以不能直接用相等
        // 代码采取的方案是取 self 的可变引用, 将此引用转换为裸指针的裸指针,
        let thin = &mut self as *mut *const T as *mut *const u8;
        // 这个赋值仅仅做了 address 的赋值, 对于瘦指针, 这个相当于赋值操作,
        // 对于胖指针, 则没有改变胖指针的元数据. 这种操作方式仅仅在极少数的情况下
        // 可以使用, 极度危险.
        unsafe {*thin = val};
        self
    }
```

本节还有一部分裸指针方法没有介绍, 留到 mem 模块分析完以后再介绍会更易于理解.

### 裸指针小结

裸指针相关的代码多数比较简单, 重要的是理解裸指针的概念, 理解 intrinsic 相关函数, 这样才能够准确的理解代码.

#### RUST 引用 `&T` 的安全要求

1. 引用的内存地址必须满足类型 T 的内存对齐要求
2. 引用的内存内容必须是初始化过的
举例:


```rust
    #[repr(packed)]
    struct RefTest {a:u8, b:u16, c:u32}
    fn main() {
        let test = RefTest{a:1, b:2, c:3};
        // 下面代码编译会有告警, 因为 test.b 内存字节位于奇数,
        // 无法用于借用
        let ref1 = &test.b
    }
 ```

 编译器出现如下警告


```rust
 |
9 | let ref1 = &test.b;
  |            ^^^^^^^
  |
  = note: `#[warn(unaligned_references)]` on by default
  = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!
  = note: for more information, see issue #82523 <https://github.com/rust-lang/rust/issues/82523>
  = note: fields of packed structs are not properly aligned, and creating a misaligned reference is undefined behavior (even if that reference is never dereferenced)
  = help: copy the field contents to a local variable, or replace the reference with a raw pointer and use `read_unaligned`/`write_unaligned` (loads and stores via `*p` must be properly aligned even when using raw pointers)

 ```

## `MaybeUninit<T>` 标准库代码分析

RUST 对于变量的要求是必须初始化后才能使用, 否则就会编译告警. 但在程序中, 总有内存还未初始化, 但需要使用的情况:
1. 从堆申请的内存块, 这些内存块都是没有初始化的
2. 需要定义一个新的泛型变量时, 并且不合适用转移所有权进行赋值时
3. 需要定义一个新的变量, 但希望不初始化便能使用其引用时
4. 定义一个数组, 但必须在后继代码对数组成员初始化时
5. ...

为了处理这种需要在代码中使用未初始化内存的情况, RUST 标准库定义了 `MaybeUninit<T>`

### `MaybeUninit<T>` 结构定义

源代码如下:

```rust
    #[repr(transparent)]
    pub union MaybeUninit<T> {
        uninit: (),
        value: ManuallyDrop<T>,
    }
```

属性 `repr(transparent)` 实际上表示外部的封装结构在内存中等价于内部的变量,
`MaybeUninit<T>` 的内存布局就是 `ManuallyDrop<T>` 的内存布局, 从后文可以看到, `ManuallyDrop<T>` 实际就是 T 的内存布局. 所以 `MaybeUninit<T>` 在内存中实质也就是 T 类型.
`MaybeUninit<T>` 容器来实现对未初始化变量的封装, 以便在不引发编译错误完成对 T 类型未初始化变量的相关操作.
如果 T 类型的变量未初始化, 那需要显式的提醒编译器不做 T 类型的 drop 操作, 因为 drop 操作可能会对 T 类型内部的变量做连锁 drop 处理, 从而引用未初始化的内容, 造成 UB(undefined behavior).
RUST 用 `ManuallyDrop<T>` 封装结构完成了对编译器的显式提示, 对于用 `ManuallyDrop<T>` 封装的变量, 生命周期终止的时候编译器不会调用 drop 操作.

### `ManuallyDrop<T>` 结构及方法

源代码如下:

```rust
#[repr(transparent)]
pub struct ManuallyDrop<T: ?Sized> {
    value: T,
}
```

重点关注的一些方法:
`ManuallyDrop<T>::new(val:T) -> ManuallyDrop<T>` , 此函数返回 ManuallyDrop 变量拥有传入的 T 类型变量所有权, 并将此块内存直接用 ManuallyDrop 封装, 对于 ManuallyDrop, 编译器不做 drop 操作, 因此也不会触发 val 的 drop.

```rust
    pub const fn new(value: T) -> ManuallyDrop<T> {
        // 所有权转移到结构体内部, value 生命周期结束时不会引发 drop
        ManuallyDrop {value}
    }
```

`ManuallyDrop<T>::into_inner(slot: ManuallyDrop<T>)->T` , 将封装的 T 类型变量所有权转移出来, 转移出来的变量生命周期终止时, 编译器会自动调用类型的 drop.

```rust
    pub const fn into_inner(slot: ManuallyDrop<T>) -> T {
        // 将 value 解封装, 所有权转移到返回值中, 编译器重新对所有权做处理
        slot.value
    }
```

`ManuallyDrop<T>::drop(slot: &mut ManuallyDrop<T>)` , drop 掉内部变量, 封装入 `ManuallyDrop<T>` 的变量一定是在程序运行的某一时期不需要编译器 drop, 所以调用这个函数的时候一定要注意正确性.
`ManuallyDrop<T>::deref(&self)-> & T` , 返回内部包装变量的引用

```rust
    fn deref(&self) -> &T {
        // 返回后, 代码可以用 & T 对 self.value 做
        // 读操作, 但不改变 drop 的规则
        &self.value
    }
```

`ManuallyDrop<T>::deref_mut(&mut self)-> & mut T` 返回内部包装变量的可变引用, 调用代码可以利用可变引用对内部变量赋值, 但不改变 drop 机制

ManuallyDrop 代码举例:

```rust
    use std::mem::ManuallyDrop;
    let mut x = ManuallyDrop::new(String::from("Hello World!"));
    x.truncate(5); // 此时会调用 deref
    assert_eq!(*x, "Hello");
    // 但对 x 的 drop 不会再发生
```

#### `MaybeUninit<T>` 创建方法

`MaybeUninit<T>::uninit()->MaybeUninit<T>` , 可视为在栈空间上申请内存的方法, 申请的内存大小是 T 类型的内存大小, 该内存没有初始化. 利用泛型和 Union 内存布局, RUST 巧妙的利用此函数在栈上申请一块未初始化内存. 此函数非常非常非常值得关注, 在需要在栈空间定义一个未初始化泛型时, 应第一时间想到 `MaybeUninit::<T>::uninit()` .

```rust
    pub const fn uninit() -> MaybeUninit<T> {
        // 变量内存布局与 T 类型完全一致
        MaybeUninit {uninit: () }
    }
```

`MaybeUninit<T>::new(val:T)->MaybeUninit<T>` , 内部用 ManuallyDrop 封装了 val, 然后用 MaybeUninit 封装 ManuallyDrop. 因为如果 T 没有初始化过, 调用这个函数会编译失败, 所以此时内存实际上已经初始化过了. 调用此函数要额外注意 val 的 drop 必须在后继有交代.

```rust
    pub const fn new(val: T) -> MaybeUninit<T> {
        //val 这个时候是初始化过的.
        MaybeUninit {value: ManuallyDrop::new(val) }
    }
```

`MaybeUninit<T>::zeroed()->MaybeUninit<T>` , 申请了 T 类型内存并清零.

```rust
    pub fn zeroed() -> MaybeUninit<T> {
        let mut u = MaybeUninit::<T>::uninit();
        unsafe {
            // 因为没有初始化, 所以不存在所有权问题,
            // 必须使用 ptr::write_bytes, 否则无法给内存清 0
            //ptr::write_bytes 直接调用了 intrinsics::write_bytes
            u.as_mut_ptr().write_bytes(0u8, 1);
        }
        u
    }
```

#### 对未初始化的变量赋值的方法

将值写入 `MaybeUninit<T>` :
`MaybeUninit<T>::write(val)->&mut T` , 这个函数将未初始化的变量初始化, 如果调用此方法后不希望解封装, 那后继的赋值使用返回的 & mut T, 再次使用 write 会出现内存安全问题. 代码如下:

```rust
    pub const fn write(&mut self, val: T) -> &mut T {
        // 下面这个赋值, 会导致原 * self 的 MaybeUninit<T> 的变量生命周期截止,
        // 会调用 drop. 但不会对内部的 T 类型变量做 drop 调用. 所以如果 * self 内部
        // 的 T 类型变量已经被初始化且需要做 drop, 那会造成内存泄漏.
        // 所以下面这个等式实际上隐含了 self 内部的 T 类型变量必须是未初始化的
        // 或者 T 类型变量不需要 drop.
        *self = MaybeUninit::new(val);
        // 函数调用后的赋值用返回的 & mut T 来做.
        unsafe {self.assume_init_mut() }
    }
```

#### 初始化后解封装的方法

用 assume_init 返回初始化后的变量并消费掉 `MaybeUninit<T>` 变量, 这是最标准的做法:
`MaybeUninit<T>::assume_init()->T` , 代码如下:

```rust
    pub const unsafe fn assume_init(self) -> T {
        // 调用者必须保证 self 已经初始化了
        unsafe {
            intrinsics::assert_inhabited::<T>();
            // 把 T 的所有权返回, 编译器会主动对 T 调用 drop
            ManuallyDrop::into_inner(self.value)
        }
    }
```

assume_init_read 是不消费 self 的情况下获得内部 T 变量, 内部 T 变量的所有权已经转移到返回变量, 后继要注意不能再次调用其他解封装函数. 否则解封装后, 会出现双份所有权, 引发两次对同一变量的 drop, 导致 UB.

```rust
    pub const unsafe fn assume_init_read(&self) -> T {

        unsafe {
            intrinsics::assert_inhabited::<T>();
            // 会调用 ptr::read
            self.as_ptr().read()
        }
    }
    // 此函即 ptr::read, 会复制一个变量, 此时注意,
    // 实际上 src 指向的变量的所有权已经转移给了返回变量,
    // 所以调用此函数的前提是 src 后继一定不能调用 T 类型的 drop 函数,
    // 例如 src 本身处于 ManallyDrop, 或后继对 src 调用 forget, 或给 src 绑定新变量.
    // 在 RUST 中, 不支持 let xxx = *(&T) 这种转移所有权的方式,
    // 因此对于只有指针输入, 又要转移所有权的, 智能利用浅拷贝进行粗暴转移.
    pub const unsafe fn read<T>(src: *const T) -> T {`
        // 利用 MaybeUninit::uninit 申请未初始化的 T 类型内存
        let mut tmp = MaybeUninit::<T>::uninit();
        unsafe {
            // 完成内存拷贝
            copy_nonoverlapping(src, tmp.as_mut_ptr(), 1);
            // 初始化后的内存解封装并返回
            tmp.assume_init()
        }
    }
```

与上个函数比较类似的 `ManuallyDrop<T>::take` 方法, 用 take 函数将变量复制并获得变量的所有权. 此时原变量仍然保留在 ManuallyDrop 中, 后继不能再调用其他解封装函数, 否则可能会出现 UB. 这里要特别注意理解 take 已经把变量的所有权转移到返回变量中.
***RUST 中的 take 方法及 replace 方法的含义是, 原变量的地址不能变动, 但内容可以获取及更新, 因为内容的获取及更新必然导致所有权的转移, 为了确保正确性, RUST 对很多类型提供了 take, replace 方法.***

```rust
    pub unsafe fn take(slot: &mut ManuallyDrop<T>) -> T {
        // 拷贝内部变量, 并返回内部变量的所有权
        // 返回后, 原有的变量所有权已经消失, 不能再用 into_inner 来返回
        // 否则会 UB
        unsafe {ptr::read(&slot.value) }
    }

```

`MaybeUninit<T>::assume_init_drop(&self)` 对于已经初始化过的 MaybeUninit<T>, 如果所有权一直没有转移, 则必须调用此函数以触发 T 类型的 drop 函数完成所有权的释放.
`MaybeUninit<T>::assume_init_ref(&self)->&T` 返回内部 T 类型变量的借用, 调用者应保证内部 T 类型变量已经初始化, 返回值按照一个普通的引用使用.*** 根据 RUST 的生命周期省略规则, 此时 & T 的生命周期小于 & self 的生命周期, 编译器可以借此检查出生命周期的错误. RUST 很多从裸指针转换为引用的生命周期都是利用函数的输入及输出的生命周期规则约束才能保证编译器对生命周期的正确检查 ***
`MaybeUninit<T>::assume_init_mut(&mut self)->&mut T` 返回内部 T 类型变量的可变借用, 调用者应保证内部 T 类型变量已经初始化, 返回值按照一个普通的可变引用使用. 此时 & mut T 的生命周期小于 & mut self. 此函数通常也用于防止 assume_init 导致的栈拷贝以提高性能.

#### `MaybeUninit<[T]>` 的方法

创建一个 MaybeUninit 的未初始化数组:
`MaybeUninit<T>::uninit_array<const LEN:usize>()->[Self; LEN]` 此处对 LEN 的使用方式需要注意, 这是不常见的一个泛型写法, 这个函数同样的申请了一块内存. 代码:

```rust
    pub const fn uninit_array<const LEN: usize>() -> [Self; LEN] {
        unsafe {MaybeUninit::<[MaybeUninit<T>; LEN]>::uninit().assume_init() }
    }
```

这里要注意区别数组类型和数组元素的初始化. 对于数组 `[MaybeUninit<T>;LEN]` 这一类型本身来说, 初始化就是确定整体的内存大小, 所以数组类型的初始化在声明后就已经完成了. 这时 assume_init() 是正确的. 这是一个理解上的盲点.

`MaybeUninit<T>::array_assume_init<const N:usize>(array: [Self; N]) -> [T; N]` 这个函数没有把所有权转移出来, 代码分析如下:

```rust
    pub unsafe fn array_assume_init<const N: usize>(array: [Self; N]) -> [T; N] {
        unsafe {
            // 最后调用是 * const T::read(), 此处 as *const _的写法可以简化代码,
            //read 后, 所有权已经转移到返回值
            // 返回后, 此数组内所有的 MaybeUninit 变量成员不能再解封装
            (&array as *const _ as *const [T; N]).read()
        }
    }
```

#### MaybeUnint<T> 典型案列

对 T 类型变量申请内存及赋值:

```rust
    use std::mem::MaybeUninit;

    // 获得一个未初始化的 i32 引用类型内存
    let mut x = MaybeUninit::<&i32>::uninit();
    // 将 & 0 写入变量, 完成初始化
    x.write(&0);
    // 将初始化后的变量解封装供后继的代码使用.
    let x = unsafe {x.assume_init() };
```

以上代码, 编译器不会对 x.write 进行报警, 这是 `MaybeUninit<T>` 的最重要的应用, 这个例子展示了 RUST 如何给未初始化内存赋值的处理方式. 调用 assume_init 前, 必须保证变量已经被正确初始化.

更复杂的初始化例子:

```rust
    use std::mem::{self, MaybeUninit};

    let data = {
    // data 在声明后实际上就已经初始化完毕.
    let mut data: [MaybeUninit<Vec<u32>>; 1000] = unsafe {
        // 这里注意实际调用是
        //MaybeUninit::<[MaybeUninit<Vec<u32>>;1000]>::uninit(),
        //RUST 的类型推断机制完成了泛型实例化
        MaybeUninit::uninit().assume_init()
    };

    for elem in &mut data[..] {
    elem.write(vec![42]);
    }

    // 直接用 transmute 完成整个数组类型的转换
    // 仔细思考一下, 这里除了用 transmute, 似乎没有其他办法了,
    unsafe {mem::transmute::<_, [Vec<u32>; 1000]>(data) }
    };

    assert_eq!(&data[0], &[42]);
```

下面例子说明一块内存被 `MaybeUnint<T>` 封装后, 编译器将不再对其做释放, 必须在代码中显式释放:

```rust
    use std::mem::MaybeUninit;
    use std::ptr;

    let mut data: [MaybeUninit<String>; 1000] = unsafe { MaybeUninit::uninit().assume_init() };
    // 初始化了 500 个 String 变量
    let mut data_len: usize = 0;
    for elem in &mut data[0..500] {
        //write 没有将所有权转移出 ManuallyDrop
        elem.write(String::from("hello"));
        data_len += 1;
    }
    // 编译器无法自动调用 drop 释放 String 变量,
    // 必须显式用 drop_in_place 释放
    for elem in &mut data[0..data_len] {
        // 实际上也可以调用 assume_init_drop 来完成此工作
        unsafe {ptr::drop_in_place(elem.as_mut_ptr()); }
    }
```

上例中, 在没有 assume_init() 调用的情况下, 必须手工调用 drop_in_place 释放内存.
`MaybeUninit<T>` 是一个非常重要的类型结构, 未初始化内存是编程中不可避免要遇到的情况, `MaybeUninit<T>` 也就是 RUST 编程中必须熟练使用的一个类型.

## 裸指针模块再分析

有了 `MaybeUnint<T>` 做基础后, 可以对裸指针其他至关重要的标准库函数做出分析

`ptr::read<T>(src: *const T) -> T` 此函数在 `MaybeUninit<T>` 节中已经给出了代码, ptr::read 是对所有类型通用的一种复制方法, 需要指出, 此函数完成浅拷贝, 复制后, src 指向的变量的所有权会转移至返回值. 所以, 调用此函数的代码必须保证 src 指向的变量生命周期结束后不会被编译器自动调用 drop, 否则可能导致重复 drop, 出现 UB 问题.

`ptr::read_unaligned<T>(src: *const T) -> T` 当数据结构中有未内存对齐的成员变量时, 需要用此函数读取内容并转化为内存对齐的变量. 否则会引发 UB(undefined behaiver) 如下例:

从字节数组中读一个 usize 的值:


```rust
    use std::mem;

    fn read_usize(x: &[u8]) -> usize {
        assert!(x.len() >= mem::size_of::<usize>());

        let ptr = x.as_ptr() as *const usize;
        // 此处必须用 ptr::read_unaligned, 因为不确定字节是否对齐
        unsafe {ptr.read_unaligned() }
    }
```

例子中, 为了从 byte 串中读取一个 usize, 需要用 read_unaligned 来获取值, 不能象 C 语言那样通过指针类型转换直接获取值.

`ptr::write<T>(dst: *mut T, src: T)` 代码如下:

```rust
pub const unsafe fn write<T>(dst: *mut T, src: T) {
    unsafe {
        // 浅拷贝
        copy_nonoverlapping(&src as *const T, dst, 1);
        // 必须调用 forget, 这里所有权已经转移. 不允许再对 src 做 drop 操作
        intrinsics::forget(src);
    }
}
```

write 函数本质上就是一个所有权转移的操作. 完成 src 到 dst 的浅拷贝, 然后调用了 forget(src), 这使得 src 的 Drop 不再被调用. 从而将所有权转移到 dst. 此函数是 mem::replace, mem::transmute_copy 的基础. 底层由 intrisic::copy_no_overlapping 支持.
这个函数中, 如果 dst 已经初始化过, 那原 dst 变量的所有权将被丢失掉, 有可能引发内存泄漏.

`ptr::write_unaligned<T>(dst: *mut T, src: T)` 与 read_unaligned 相对应. 举例如下:

```rust
    #[repr(packed, C)]
    struct Packed {
        _padding: u8,
        unaligned: u32,
    }

    let mut packed: Packed = unsafe {std::mem::zeroed() };

    // Take the address of a 32-bit integer which is not aligned.
    // In contrast to `&packed.unaligned as *mut _`, this has no undefined behavior.
    // 对于结构中字节没有按照 2 幂次对齐的成员, 要用 addr_of_mut! 宏来获得地址, 无法用取引用的方式.
    let unaligned = std::ptr::addr_of_mut!(packed.unaligned);

    unsafe {std::ptr::write_unaligned(unaligned, 42) };

     assert_eq!({packed.unaligned}, 42); // `{...}` forces copying the field instead of creating a reference.
```

`ptr::read_volatile<T>(src: *const T) -> T` 是 intrinsics::volatile_load 的封装
`ptr::write_volatile<T>(dst: *mut T, src:T)` 是 intrinsics::volatiel_store 的封装

`ptr::macro addr_of($place:expr)` 因为用 & 获得引用必须是字节按照 2 的幂次对齐的地址, 所以用这个宏获取非地址对齐的变量地址

```rust
pub macro addr_of($place:expr) {
    // 关键字是 & raw const, 这个是 RUST 的原始引用语义,
    // 但目前还没有在官方做公开. 区别与 &, & 要求地址必
    // 须满足字节对齐和初始化,&raw 则没有这个问题
    &raw const $place
}
```

`ptr::macro addr_of_mut($place:expr)` 作用同上.

```rust
pub macro addr_of_mut($place:expr) {
    &raw mut $place
}
```

指针的通用函数请参考 [Rust 库函数参考](https://doc.rust-lang.org/core/ptr/index.html#functions)

## `NonNull<T>` 代码分析

结构体定义如下:

```rust
#[repr(transparent)]
pub struct NonNull<T: ?Sized> {
    pointer: *const T,
}
```

属性 `repr(transparent)` 实际上表示外部的封装结构在内存中等价于内部的变量. `NonNull<T>` 在内存中与 `*const T` 完全一致. 可以直接强转为 `* const T` .
裸指针的值因为可以为 0, 如果敞开来用, 会有很多无法控制的代码隐患. 按照 RUST 的习惯, 标准库定义了非 0 的指针封装结构 `NonNull<T>` , 从而可以用 `Option<NonNull<T>>` 来对值可能为 0 的裸指针做出强制安全代码逻辑. 不需要 Option 的则认为裸指针不会取值为 0.
`NonNull<T>` 本身是协变 (covarient) 类型.
**RUST 中的协变, 在 RUST 中, 不同的生命周期被视为 * 不同的类型 *, 对于带有生命周期的类型变量做赋值操作时, 仅允许子类型赋给基类型 (长周期赋给短周期), 为了从基本类型生成复合类型的子类型和基类型的关系, RUST 引入了协变性. 从基本类型到复合类型的协变性有 协变(covarient)/ 逆变(contracovarient)/ 不变(invarient) 三种 **
程序员分析代码时, 可以从基本类型之间的生命周期关系及协变性确定复合类型变量之间的生命周期关系, 从而做合适的赋值操作.

因为 `NonNull<T>` 实际上是封装 `* mut T` 类型, 但 `* mut T` 与 `NonNull<T>` 的协变性不同, 所以程序员如果不能确定需要协变类型, 就不要使用 `NonNull<T>`

### `NonNull<T>` 创建关联方法

创建一个悬垂 (dangling) 指针, 保证指针满足类型内存对齐要求. 该指针可能指向一个正常的变量, 所以不能认为指向的内存是未初始化的. dangling 实际表示 `NonNull<T>` 无意义, 与 `NonNull<T>` 的本意有些违背, 因为这个语义可以用 None 来实现.

```rust
    pub const fn dangling() -> Self {
        unsafe {
            // 取内存对齐地址作为裸指针的地址.
            // 调用者应保证不对此内存地址进行读写
            let ptr = mem::align_of::<T>() as *mut T;
            NonNull::new_unchecked(ptr)
        }
    }
```

new 函数, 由输入的 `*mut T` 裸指针创建 `NonNull<T>` . 代码如下:

```rust
    pub fn new(ptr: *mut T) -> Option<Self> {
        if !ptr.is_null() {
            //ptr 的安全性已经检查完毕
            Some(unsafe { Self::new_unchecked(ptr) })
        } else {
            None
        }
    }
```

`` `NonNull::<T>::new_unchecked(* mut T)->Self` ` ` 用 ` * mut T ` 生成 NonNull<T>, 不检查 ` * mut T ` 是否为 0, 调用者应保证 ` * mut T` 不为 0.

from_raw_parts 函数, 类似裸指针的 from_raw_parts.

```rust
    pub const fn from_raw_parts(
        data_address: NonNull<()>,
        metadata: <T as super::Pointee>::Metadata,
    ) -> NonNull<T> {
        unsafe {
            // 需要先用 from_raw_parts_mut 形成 * mut T 指针
            NonNull::new_unchecked(super::from_raw_parts_mut(data_address.as_ptr(), metadata))
        }
    }
```

由 From trait 创建 `NonNull<T>`

```rust
impl<T: ?Sized> const From<&mut T> for NonNull<T> {
    fn from(reference: &mut T) -> Self {
        unsafe {NonNull { pointer: reference as *mut T} }
    }
}

impl<T: ?Sized> const From<&T> for NonNull<T> {
    fn from(reference: &T) -> Self {
        // 此处说明 NonNull 也可以接收不可变引用,
        // 代码要注意在后继不能将这个变量转换为可变引用
        unsafe {NonNull { pointer: reference as *const T} }
    }
}
```

### `NonNull<T>` 类型转换方法

`NonNull<T>` 的方法基本与 `*const T/* mut T` 相同, 也容易理解, 下文仅做罗列和简单说明
`NonNull::<T>::as_ptr(self)->* mut T` 返回内部的 pointer 裸指针
`` `NonNull::<T>::as_ref<'a>(&self)->&'a T ` `` 返回的引用的生命周期与 self 的生命周期独立, 由调用代码保证正确性.
`` `NonNull::<T>::as_mut<'a>(&mut self)->&'a mut T` `` 与 as_ref 类似, 但返回可变引用.
`` `NonNull::<T>::cast<U>(self)->NonNull<U>` `` 指针类型转换, 程序员应该保证 T 和 U 的内存布局相同

### `NonNull<[T]>` 方法

`` `NonNull::<[T]>::slice_from_raw_parts(data: NonNull<T>, len: usize) -> Self` ` ` 将类型指针转化为类型的切片类型指针, 实质是 ` ptr::slice_from_raw_parts` 的一种包装.
`NonNull::<[T]>::as_non_null_ptr(self) -> NonNull<T>` * const [T]::as_ptr 的 NonNull 版本

### `NonNull<T>` 的使用实例

以下的实例展示了 `NonNull<T>` 在动态申请堆内存的使用:

```rust
    impl Global {
        fn alloc_impl(&self, layout: Layout, zeroed: bool) -> Result<NonNull<[u8]>, AllocError> {
            match layout.size() {
                0 => Ok(NonNull::slice_from_raw_parts(layout.dangling(), 0)),
                // SAFETY: `layout` is non-zero in size,
                size => unsafe {
                    //raw_ptr 是 *const u8 类型
                    let raw_ptr = if zeroed {alloc_zeroed(layout) } else { alloc(layout) };
                    //NonNull::new 处理了 raw_ptr 为零的情况, 返回 NonNull<u8>,
                    // 此时内存长度还与 T 不匹配
                    let ptr = NonNull::new(raw_ptr).ok_or(AllocError)?;
                    // 将 NonNull<u8> 转换为 NonNull<[u8]>, NonNull<[u8]> 已经
                    // 是类型 T 的内存长度. 后继可以直接转换为 T 类型的指针了.
                    // 这个转换极为重要.
                    Ok(NonNull::slice_from_raw_parts(ptr, size))
                },
            }
        }
        ....
    }
```

基本上, 如果 `* const T/*mut T` 要跨越函数使用, 或作为数据结构体的成员时, 应将之转化成 `NonNull<T>` 或 `Unique<T>` . `*const T` 应该仅仅保持在单一函数内.

#### `NonNull<T>` 与 `MaybeUninit<T>` 相关函数

```NonNull<T>::as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T>

```
```rust
    pub unsafe fn as_uninit_ref<'a>(&self) -> &'a MaybeUninit<T> {
        // self.cast 将 NonNull<T> 转换为 NonNull<MaybeUninit<T>>
        //self.cast.as_ptr 将 NonNull<MaybeUninit<T>> 转换为 *mut MaybeUninit<T>
        unsafe {&*self.cast().as_ptr() }
    }
```

```NonNull<T>::as_uninit_mut<'a>(&self) -> &'a mut MaybeUninit<T>

```
```NonNull<[T]>::as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>]```

```rust
    pub unsafe fn as_uninit_slice<'a>(&self) -> &'a [MaybeUninit<T>] {
        // 下面的函数调用 ptr::slice_from_raw_parts
        unsafe {slice::from_raw_parts(self.cast().as_ptr(), self.len()) }
    }
```

```NonNull<[T]>::as_uninit_slice_mut<'a>(&self) -> &'a mut [MaybeUninit<T>]

```

## `Unique<T>` 代码分析

`Unique<T>` 类型结构定义如下:
```rust
    #[repr(transparent)]
    pub struct Unique<T: ?Sized> {
        pointer: *const T,
        _marker: PhantomData<T>,
    }
```

和 `NonNull<T>` 对比, `Unique<T>` 多了 `PhantomData<T>` 类型成员. 这个定义使得编译器知晓, `Unique<T>` 拥有了 pointer 指向的内存的所有权, `NonNull<T>` 没有这个特性. 具备所有权后, `Unique<T>` 可以实现 Send, Sync 等 trait. 因为获得了所有权, 此块内存无法用于他处, 这也是 Unique 的名字由来原因.
指针在被 `Unique<T>` 封装前, 必须保证是 NonNull 的.
对于 RUST 从堆内存申请的内存块, 其指针都是用 `Unique<T>` 封装后来作为智能指针结构体内部成员变量, 保证智能指针结构体拥有申请出来的内存块的所有权.

`Unique<T>` 模块的函数及代码与 `NonNull<T>` 函数代码相类似, 此处不分析.
`Unique::cast<U>(self)->Unique<U>` 类型转换, 程序员应该保证 T 和 U 的内存布局相同
`Unique::<T>::new(* mut T)->Option<Self>` 此函数内部判断 * mut T 是否为 0 值
`Unique::<T>::new_unchecked(* mut T)->Self` 封装 * mut T, 调用代码应该保证 * mut T 的安全性
 `Unique::as_ptr(self)->* mut T`

`Unique::as_ref(&self)->& T` 因为 Unique 具备所有权, 此处 & T 的生命周期与 self 相同, 不必特别声明声明周期
`Unique::as_mut(&mut self)->& mut T` 同上

## mem 模块函数

### 泛型类型创建

`mem::zeroed<T>() -> T` 返回一个内存块清零的泛型变量, 内存块在栈空间, 代码如下:

```rust
pub unsafe fn zeroed<T>() -> T {
    // 调用代码必须确认 T 类型的变量可以取全零值
    unsafe {
        intrinsics::assert_zero_valid::<T>();
        MaybeUninit::zeroed().assume_init()
    }
}
```

`mem::uninitialized<T>() -> T` 返回一个未初始化过的泛型变量, 内存块在栈空间.

```rust
pub unsafe fn uninitialized<T>() -> T {
    // 调用者必须确认 T 类型的变量允许未初始化的任意值
    unsafe {
        intrinsics::assert_uninit_valid::<T>();
        MaybeUninit::uninit().assume_init()
    }
}
```

### 泛型类型拷贝与替换

下面的 take 及 replace 都是针对在只有引用的情况下对变量值作更新. 这对于结构体成员更新值非常重要. 因为在使用结构体引用时, 无法单独的转移结构体成员的所有权, 而更新值往往需要获取所有权, 修改, 然后再将新值赋回. 此场景一般用 take 来获取所有权, 修改后再用 replace 将值更新.

`mem::take<T: Default>(dest: &mut T) -> T` 将 dest 设置为默认内容 (不改变所有权), 用一个新变量返回 dest 的内容. 这里有一个坑, 即任何类型的 default() 必然能够满足多次 drop 不会出现内存安全问题.

```rust
pub fn take<T: Default>(dest: &mut T) -> T {
    // 即 mem::replace, 见下文
    // 此处, 对于引用类型, 编译器禁止用 * dest 来转移所有权,
    // 所以不能用 let xxx = *dest; xxx 这种形式返回 T
    // 其他语言简单的事情在 RUST 中必须用一个较难理解的方
    // 式来进行解决. replace() 对所有权有仔细的处理
    replace(dest, T::default())
}
```

`mem::replace<T>(dest: &mut T, src: T) -> T` 用 src 的内容赋值 dest(不改变所有权), 用一个新变量返回 dest 的内容. replace 函数的难点在于了解所有权的转移.

```rust
pub const fn replace<T>(dest: &mut T, src: T) -> T {
    unsafe {
        // 因为要替换 dest, 所以必须对 dest 原有变量的所有权做处理,
        // 因此先用 read 将 * dest 的所有权转移到 T, 交由调用者进行处理,
        //RUST 不支持对引用类型做解引用的相等来转移所有权. 将一个引用
        // 的所有权进行转移的方式只有粗暴的内存浅拷贝这种方法.
        // 使用这个函数, 调用代码必须了解 T 类型的情况, T 类型有可能需要
        // 显式的调用 drop 函数. ptr::read 前文已经分析过.
        let result = ptr::read(dest);
        //ptr::write 本身会导致 src 的所有权转移到 dest, 后继不允许
        // 在 src 生命周期终止时做 drop.ptr::write 会用 forget(src) 做到这一点.
        ptr::write(dest, src);
        result
    }
}
```

`mem::transmute_copy<T, U>(src: &T) -> U` 新建类型 U 的变量, 并把 src 的内容拷贝到 U. 调用者应保证 T 类型的内容与 U 一致, src 后继的所有权问题需要做处理.

```rust
pub const unsafe fn transmute_copy<T, U>(src: &T) -> U {
    if align_of::<U>() > align_of::<T>() {
        // 如果两个类型字节对齐 U 大于 T. 使用 read_unaligned
        unsafe {ptr::read_unaligned(src as *const T as *const U) }
    } else {
        // 用 read 即可完成
        unsafe {ptr::read(src as *const T as *const U) }
    }
}
```

#### 所有权转移的底层实现

所有权的本质是只能对变量做一次 drop 操作. 变量的 drop 操作会引起变量结构体内部成员的链式 drop.
所以, 只要引发了变量的浅拷贝, 所有权便被转移. 原先放置变量的那块内存就必须被处理, forget 及 ManuallyDrop 是两种典型方案.
不涉及裸指针的代码, 一般不必考虑所有权必须人工处理的情况. 但一旦涉及到裸指针, 那就必须注意看是否出现了一个变量的双份或多份拷贝, 每多一次拷贝, 意味着编译器会对变量多做一次 drop, 触发 UB.

##### 变量调用 drop 的时机

如下例子:

```rust
struct TestPtr {a: i32, b:i32}
impl Drop for TestPtr {
    fn drop(&mut self) {
        println!("{} {}", self.a, self.b);
    }
}
fn main() {
   let test = Box::new(TestPtr{a:1,b:2});
   let test1 = *test;
   let mut test2 = TestPtr{a:2, b:3};
   // 此行代码会导致先释放 test2 拥有所有权的变量,
   // 然后再给 test2 赋值. 代码后的输出会给出证据
   // 将 test1 的所有权转移给 test2, 无疑代表着 test2
   // 现有的所有权会在后继无法访问, 因此 drop 被立即调用.
   test2 = test1;
   println!("{:?}", test2);
}
```

输出:
2 3
TestPtr {a: 1, b: 2}
1 2

### 其他函数

`mem::forget<T>(t:T)` 通知 RUST 不做变量的 drop 操作

```rust
pub const fn forget<T>(t: T) {
    // 没有使用 intrinsic::forget, 实际上效果
    // 一致, 这里应该是尽量规避用 intrinsic 函数
    let _ = ManuallyDrop::new(t);
}
```

`mem::forget_unsized<T:Sized?>` 对 intrinsics::forget 的封装
`mem::size_of<T>()->usize` / `mem::min_align_of<T>()->usize` / `mem::size_of_val<T>(val:& T)->usize` / `mem::min_align_of_val<T>(val: &T)->usize` / `mem::needs_drop<T>()->bool` 基本就是直接调用 intrinsic 模块的同名函数
`mem::drop<T>(_x:T)` 释放内存

## RUST 堆内存申请及释放

### RUST 类型系统的内存布局

RUST 提供了 `Layout` 内存布局类型, 此布局类型结构主要用于做堆内存申请.
`Layout` 的数据结构如下:

```rust
pub struct Layout {
    // 类型需占用的内存大小, 用字节数目表示
    size_: usize,
    //  按照此字节数目进行类型内存对齐,
    //  NonZeroUsize 见代码后面文字分析
    align_: NonZeroUsize,
}
```

* `NonZeroUsize` 是一种非 0 值的 usize, 这种类型主要应用于不可取 0 的值, 本结构中, 字节对齐属性变量不能被置 0, 所以用 `NonZeroUsize` 来确保安全性. 如果用 usize 类型, 那代码中就可能会把 0 置给 align_, 导致 bug 产生. 这是 RUST 的一个设计规则, 所有的约束要在类型定义即显性化, 从而使 bug 在编译中就被发现.*

每一个 RUST 的类型都有自身独特的内存布局 Layout. 一种类型的 Layout 可以用 `intrinsic::<T>::size_of()` 及 `intrinsic::<T>::min_align_of()` 获得的类型内存大小和对齐来获得.
RUST 的内存布局更详细原理阐述请参考 [RUST 内存布局] (https://doc.rust-lang.org/nomicon/data.html),
Layout 比较有典型意义的函数:

```rust
impl Layout {
    ...
    ...

    //array 函数是计算 n 个 T 类型变量形成的数组所需的 Layout,
    // 是从代码了解 Rust Layout 概念的一个好的实例
    // 这里主要注意的是 T 类型的对齐会导致内存申请不是 T 类型的内存大小 * n
    // 而且对齐也是数组的算法
    pub fn array<T>(n: usize) -> Result<Self, LayoutError> {
        // 获得 n 个 T 类型的内存 Layout
        let (layout, offset) = Layout::new::<T>().repeat(n)?;
        debug_assert_eq!(offset, mem::size_of::<T>());
        // 以完全对齐的大小  , 得出数组的 Layout
        Ok(layout.pad_to_align())
    }

    // 计算 n 个 T 类型需要的内存 Layout, 以及成员之间的空间
    pub fn repeat(&self, n: usize) -> Result<(Self, usize), LayoutError> {
        // 所有的成员必须以成员的对齐大小来做内存对齐, 首先计算对齐需要的 padding 空间
        let padded_size = self.size() + self.padding_needed_for(self.align());
        // 计算共需要多少内存空间, 如果溢出, 返回 error
        let alloc_size = padded_size.checked_mul(n).ok_or(LayoutError)?;

        // 由已经验证过得原始数据生成 Layout, 并返回单成员占用的空间
        unsafe {Ok((Layout::from_size_align_unchecked(alloc_size, self.align()), padded_size)) }
    }

    // 填充以得到一个与 T 类型完全对齐的, 最小的内存大小的 Layout
    pub fn pad_to_align(&self) -> Layout {
        // 得到 T 类型与对齐之间的空间大小
        let pad = self.padding_needed_for(self.align());
        // 完全对齐的大小
        let new_size = self.size() + pad;

        // 以完全对齐的大小生成新的 Layout
        Layout::from_size_align(new_size, self.align()).unwrap()
    }

    // 计算 T 类型长度与完全对齐的差
    pub const fn padding_needed_for(&self, align: usize) -> usize {
        let len = self.size();

        // 实际上相当与 C 语言的表达式
        //   len_rounded_up = (len + align - 1) & !(align - 1);
        // 就是对对齐大小做除, 如果有余数, 商加 1, 是一种常用的方式.
        // 但注意, 在 rust 中 C 语言的 "+" 等同于 wrapping_add, C 语言的 "-" 等同于
        // wrapping_sub
        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);
        // 减去 len, 得到差值
        len_rounded_up.wrapping_sub(len)
    }

    // 不检查输入参数, 根据输入参数表示的原始数据生成 Layout 变量, 调用代码应保证安全性
    pub const unsafe fn from_size_align_unchecked(size: usize, align: usize) -> Self {
        // 必须保证 align 满足不为 0.
        Layout {size_: size, align_: unsafe { NonZeroUsize::new_unchecked(align) } }
    }

    // 对参数进行检查, 生成一个类型的 Layout
    pub const fn from_size_align(size: usize, align: usize) -> Result<Self, LayoutError> {
        // 必须保证对齐是 2 的幂次
        if !align.is_power_of_two() {
            return Err(LayoutError);
        }

        // 满足下面的表达式, 则 size 将不可能对齐
        if size > usize::MAX - (align - 1) {
            return Err(LayoutError);
        }

        // 参数已经检查完毕.
        unsafe {Ok(Layout::from_size_align_unchecked(size, align)) }
    }
    ...
    ...
}
```

### `#[repr(transparent)]` 内存布局模式

repr(transparent) 用于仅包含一个成员变量的类型, 该类型的内存布局与成员变量类型的内存布局完全一致. 类型仅仅具备编译阶段的意义, 在运行时, 类型变量与其成员变量可以认为是一个相同变量, 可以相互无障碍类型转换. 使用 repr(transparent) 布局的类型基本是一种封装结构.

#### `#[repr(packed)]` 内存布局模式

强制类型成员变量以 1 字节对齐, 此种结构在协议分析和结构化二进制数据文件中经常使用

#### `#[repr(align(n))]` 内存布局模式

强制类型以 2 的幂次对齐

#### `#[repr(RUST)]` 内存布局模式

默认的布局方式, 采用此种布局, RUST 编译器会根据情况来自行优化内存

#### `#[repr(C)]` 内存布局模式

采用 C 语言布局方式, 所有结构变量按照声明的顺序在内存排列. 默认 4 字节对齐.

### RUST 堆内存申请与释放接口

资深的 C/C++ 程序员都了解, 在大型系统开发时, 往往需要自行实现内存管理模块, 以根据系统的特点优化内存使用及性能, 并作出内存跟踪.
对于操作系统, 内存管理模块更是核心功能.
对于 C/C++ 小型系统, 没有内存管理, 仅仅是调用操作系统的内存系统调用, 内存管理交给操作系统负责. 操作系统内存管理模块接口是内存申请及内存释放的系统调用
对于 GC 语言, 内存管理由虚拟机或语言运行时负责, 利用语言提供的 new 来完成类型结构内存获取.
RUST 的内存管理分成了三个界面:
1. 由智能指针类型提供的类型创建函数, 一般有 new, 与其他的 GC 类语言相同, 同时增加了一些更直观的函数.
2. 智能指针使用实现 Allocator Trait 的类型做内存申请及释放. Allocator 使用编译器提供的函数名申请及释放内存.
3. 实现了 GlobalAlloc Trait 的类型来完成独立的内存管理模块, 并用 #[global_allocator] 注册入编译器, 替代编译器默认的内存申请及释放函数.
这样, RUST 达到了:
1. 对于小规模的程序, 拥有与 GC 语言相类似的内存获取机制
2. 对于大型程序和操作系统内核, 从语言层面提供了独立的内存管理模块接口, 达成了将现代语法与内存管理模块共同存在, 相互配合的目的.
但因为所有权概念的存在, 从内存申请到转换为类型系统仍然还存在复杂的工作.
堆内存申请和释放的 Trait GlobalAlloc 定义如下:

```rust
pub unsafe trait GlobalAlloc {
    // 申请内存, 因为 Layout 中内存大小不为 0, 所以, alloc 不会申请大小为 0 的内存
    unsafe fn alloc(&self, layout: Layout) -> *mut u8;
    // 释放内存
    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout);

    // 申请后的内存应初始化为 0
    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {
        let size = layout.size();
        let ptr = unsafe {self.alloc(layout) };
        if !ptr.is_null() {
            // 此处必须使用 write_bytes, 确保每个字节都清零
            unsafe {ptr::write_bytes(ptr, 0, size) };
        }
        ptr
    }

    // 其他方法
    ...
    ...
}
```

在内核编程或大的框架系统编程中, 开发人员通常开发自定义的堆内存管理模块, 模块实现 GlobalAlloc Trait 并添加 #[global_allocator] 标识. 对于用户态, RUST 标准库有默认的 GlobalAlloc 实现.

```rust
extern "Rust" {
    // 编译器会将实现了 GlobalAlloc Trait, 并标记
    //#[global_allocator] 的四个方法自动转化为以下的函数
    #[rustc_allocator]
    #[rustc_allocator_nounwind]
    fn __rust_alloc(size: usize, align: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_dealloc(ptr: *mut u8, size: usize, align: usize);
    #[rustc_allocator_nounwind]
    fn __rust_realloc(ptr: *mut u8, old_size: usize, align: usize, new_size: usize) -> *mut u8;
    #[rustc_allocator_nounwind]
    fn __rust_alloc_zeroed(size: usize, align: usize) -> *mut u8;
}

// 对__rust_xxxxx_再次封装
pub unsafe fn alloc(layout: Layout) -> *mut u8 {
    unsafe {__rust_alloc(layout.size(), layout.align()) }
}

pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {
    unsafe {__rust_dealloc(ptr, layout.size(), layout.align()) }
}

pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {
    unsafe {__rust_realloc(ptr, layout.size(), layout.align(), new_size) }
}

pub unsafe fn alloc_zeroed(layout: Layout) -> *mut u8 {
    unsafe {__rust_alloc_zeroed(layout.size(), layout.align()) }
}

```

再实现 Allocator Trait, 对以上四个函数做封装处理. 作为 RUST 其他模块对堆内存的申请和释放接口.

```rust
pub unsafe trait Allocator {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError>;

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        let ptr = self.allocate(layout)?;
        // SAFETY: `alloc` returns a valid memory block
        // 复杂的类型转换, 实际是调用 *const u8::write_bytes(0, layout.size_)
        unsafe {ptr.as_non_null_ptr().as_ptr().write_bytes(0, ptr.len()) }
        Ok(ptr)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout);

    ...
}
```

Global 实现了 Allocator Trait. Rust 大部分 alloc 库数据结构的实现使用 Global 作为 Allocator.

```rust
unsafe impl Allocator for Global {
    fn allocate(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        // 上文已经给出 alloc_impl 的说明
        self.alloc_impl(layout, false)
    }

    fn allocate_zeroed(&self, layout: Layout) -> Result<NonNull<[u8]>, AllocError> {
        self.alloc_impl(layout, true)
    }

    unsafe fn deallocate(&self, ptr: NonNull<u8>, layout: Layout) {
        if layout.size() != 0 {
            // SAFETY: `layout` is non-zero in size,
            // other conditions must be upheld by the caller
            unsafe {dealloc(ptr.as_ptr(), layout) }
        }
    }
    ...
    ...
}
```

Allocator 使用 GlobalAlloc 接口获取内存, 然后将 GlobalAlloc 申请到的 * mut u8 转换为确定大小的单一指针 NonNull<[u8]>, 并处理申请内存可能出现的不成功. NonNull<[u8]> 此时内存布局与 T 的内存布局已经相同, 后继可以转换为真正需要的 T 的指针并进一步转化为相关类型的引用, 从而符合 RUST 类型系统安全并进行后继的处理.
以上是堆内存的申请和释放. 基于泛型, RUST 也巧妙实现了栈内存的申请和释放机制 `mem::MaybeUninit<T>`

用 Box 的内存申请做综合举例:

```rust
    // 此处 A 是一个 A:Allocator 类型
    pub fn try_new_uninit_in(alloc: A) -> Result<Box<mem::MaybeUninit<T>, A>, AllocError> {
        // 实质是 T 类型的内存 Layout
        let layout = Layout::new::<mem::MaybeUninit<T>>();
        //allocate(layout)? 返回 NonNull<[u8]>,
        //NonNull<[u8]>::<MaybeUninit<T>>::cast() 返回
        //NonNull<MaybeUninit<T>>
        let ptr = alloc.allocate(layout)?.cast();
        //as_ptr 成为 *mut MaybeUninit<T> 类型裸指针
        unsafe {Ok(Box::from_raw_in(ptr.as_ptr(), alloc)) }
    }

    pub unsafe fn from_raw_in(raw: *mut T, alloc: A) -> Self {
        // 使用 Unique 封装 * mut T, 并拥有了 * mut T 指向的变量的所有权
        Box(unsafe { Unique::new_unchecked(raw) }, alloc)
    }
```

以上代码可以看到, `NonNull<[u8]>` 可以直接通过 cast 转换为 `NonNull<MaybeUninit<T>>` , 这是另一种 `MaybeUninit<T>` 的生成方法, 直接通过指针类型转换将未初始化的内存转换为 `MaybeUninit<T>` .

## RUST 的全局变量内存探讨

RUST 支持 const 及 static 类型的全局变量, 且 static 支持可写操作. 所有对 static 的写操作都是 unsafe 的.
需要特别注意的, 全局变量不支持非 Copy trait 类型所有权转移, 这也很好理解, 所有权转移实际上一个内存 "move" 的操
作. 但 static 变量的内存显然是没有办法 "move" 的.

static 这一性质导致如果要有转移所有权的操作, 必须使用 mem::replace 的方式进行, RUST 标准库中很多类型基于 mem::replace 实现类型自身的 replace 方法或 take 方法.

C/C++ 程序员比较习惯于设计全局变量及其变种静态方法, RUST 的全局变量所有权的限制会对这个设计思维有较大的冲击
推荐这篇全局变量的链接: [rust-global-variable](https://www.sitepoint.com/rust-global-variables/)
下面是摘录的一张图

![全局变量使用](./rust%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.png)

# RUST 所有权, 生命周期, 借用探讨

RUST 在定义一个变量时, 实际上把变量在逻辑上分成了两个部分, 变量的内存块与变量内容.
变量类型定义了内存块内容的格式, 变量声明语句定义了一个内存块, 变量初始化赋值则在内存块中写入初始化变量内容.
** 所有权 ** 指变量内容的独占性. 所有权转移指的是变量内容在不同的内存块之间的转移 (浅拷贝). 当变量内容转移到新的内存块, 旧的内存块就失去了这个变量内容的所有权. 由此可见, 变量名实际仅代表一个内存块, 内存块的变量内容与变量名是一个暂时关联关系, RUST 定义这种关联关系为 ** 绑定 **.
设计所有权的目的是保证对变量进行清理操作的正确, 如果一个变量内容在多个内存块中有效, 变量清理的正确性用静态编译的方法无法保证.
这里有个例外, 就是实现 Copy trait 的类型变量不做所有权转移操作, 实现 Copy trait 的类型可通过栈拷贝完成变量内容赋值, 清理也可以仅通过通常的调用栈返回完成.
RUST 被设计成自动调用变量类型的 drop 以完成清理, 对变量的生命周期跟踪成为一个必然的选择, 在判断变量的生命周期终结的时候调用变量的 drop 函数.

RUST 采用生命周期仅与内存块 (变量名) 相关联的设计, 这样的设计容易对生命周期进行跟踪. 没有绑定所有权的内存块在生命周期终结不做任何操作, 拥有所有权的内存块生命周期终结会自动触发变量的 drop 操作.
如果仅仅考虑 drop 操作, 那生命周期的方案不会太复杂, 但 RUST 决定用生命周期同时解决另一个问题, 变量引用导致的野指针问题. 因为所有权的关系, RUST 将变量引用改了一个 RUST 的名字——** 借用 **, 意味着对所有权的借用.
用生命周期解决借用导致的野指针问题思路很简单, 就是借用的生命周期应该短于所有权的生命周期. 但这个简单的思路却需要极为复杂的设计来完成, 对这个复杂设计的理解也成了 RUST 最被人诟病的点.

理想的生命周期方案是完全由编译器搞定, 程序员不要参与. 但这显然不可能, 编译器没办法在所有的情况下都能够完成全部的推断, 势必需要程序员在编码中给出提示. 生命周期因此成为 rust 的一个语法部分.

首先, 生命周期被设计成一种实现继承语法的 ** 类型 **, ** 每一个生命周期都是一个类型 **, 不同的生命周期之间的关系用类型继承语法来完成. 生命周期类型的继承具体而言: 假设有两个生命周期类型 A 和 B, 如果 A 完全被 B 包含在内, 那就说 B 继承于 A. A 是基类型, B 是子类型. 从继承的概念, B 类型能被转换为 A 类型, A 类型无法转换为 B 类型. 也就是说 B 类型的值能赋给 A 类型的变量, A 类型的值无法赋给 B 类型变量.
生命周期是类型这一点与直观感觉有区别, 毕竟, 一个作用域给人的感觉就应该是个值. 但是, 用类型这个方案:
1. 可以利用类型系统来完成生命周期方案, 没有给 rust 编译器增加太大的负担, 代码也几乎不受影响.
2. 利用继承语法, 在变量赋值时根据类型能否转换完成生命周期长短的判断, 是极为巧妙的, 简化的, 自然的设计.

因为生命周期仅对内存块有意义, 而在转移所有权的操作中, 是两个不同的内存块发生的联系, 他们的生命周期彼此独立. 所以所有权转移时, 所有权变量的类型层次上不涉及生命周期类型转换. 如果类型成员中有引用, 则见下面的内容.
当对一个引用类型变量做赋值时, 便出现了生命周期类型转换, 举例分析如下:
1. 当声明一个类型引用的变量时, 例如:`let a: &i32` 实质声明了一个 i32 类型引用的内存块, 这个内存块有一个生命周期泛型, 假设为'a,
2. 假设要对此变量赋值为另一个变量的引用, 例如: `let b:i32 = 4; a = &b;` &b 实质是对 b 的内存块进行引用, 该内存块的生命周期假设为'b,
3. 赋值实质是将一个 &'b i32 类型的变量赋值给 &'a i32 类型变量. 则必然发生 ** 类型转换 ** 关系, 这时, 只有当'b 是'a 的子类型时, 即'b 长于'a 时, 这个 ** 类型转换 ** 才能被编译器认为正确.

以上实际就是生命周期的奥秘所在了, RUST 对生命周期设计的关键点就是:
1. 在变量赋值时捕捉触发生命周期类型转换的情况
2. 确保类型转换不正确时, 给出生命周期不正确的编译错误警告.

但是, 还有些其他情况需要考虑.
因为引用类型是泛型的一种, 那由泛型派生的类型的赋值也就会出现类型转换的问题, 例如: `*const T,*mut T,Box<T> ,...` 具体的类型可以参考 RUST Reference. 这时, 需要由 T 的继承关系推断出派生类型的继承关系. 这就是变异性 Variance 特性存在的意义, Variance 存在三种情况
1. 协变 covariant, 泛型是子类, 派生类型也是子类. 泛型是父类, 派生类型也是父类
2. 逆变 contravariant, 泛型是子类, 派生类型是父类. 泛型是父类, 派生类型是子类
3. 不变 invariant, 泛型的子类还是父类都推导不出派生类型是否是子类还是父类.

复合类型之间的继承的关系可根据成员变异性得出.
因为在 RUST 编程中引用派生类型及其赋值操作的广泛性, 所以变异性是一个重要的需要被理解的概念. 完整的变异性请参考 RUST Reference.

对生命周期推断的复杂性, RUST 采用了每个函数自决的方式 (推断).
每一个函数的生命周期类型转换处理正确与否在函数内完成判断 (以下为根据逻辑进行的推断, 可能不准确):
1. 函数作用域会有一个生命周期泛型;
2. 函数的定义会定义函数参数的生命周期泛型, 以及这些生命周期泛型之间的继承关系. 显然, 函数作用域生命周期泛型是所有输入参数生命周期泛型的基类型
3. 函数的定义会定义输出的生命周期泛型, 以及输出的生命周期泛型与输入参数生命周期泛型的继承关系. 如果输出是一个借用或由借用派生的类型或者有借用成员的复合类型, 则输出的生命周期泛型必须是某一输入生命周期泛型的基类型.
4. 编译器会分析函数中的作用域, 针对每个作用域生成生命周期泛型, 并形成这些生命周期泛型之间的继承关系, 当然, 函数内所有生命周期泛型都是函数作用域生命周期泛型的基类型.
5. 根据这些生命周期泛型及他们之间的继承关系, 处理函数内操作时引发的生命周期泛型类型转换, 并对错误的转换做出错警告.
6. 如果调用了其他函数, 则对调用函数的输入参数及输出之间的转换是否正确判断转移至调用函数.

如果一个复合类型内部存在引用类型成员或递归至引用类型成员, 则必须明确此复合类型的生命周期泛型与成员生命周期泛型的继承关系. 一般复合类型的生命周期应该是基类型.

RUST 编译器做了很多工作以避免生命周期泛型标注在代码中出现. 这部分的工作仍然在持续进行中.
举几个生命周期的例子:

```rust
impl *const T{
    pub const unsafe fn as_ref<'a>(self) -> Option<&'a T> {
        if self.is_null() { None} else { unsafe { Some(&*self) } }
    }
}
```

因为 * const T 没有生命周期类型与之相关. 所以上面这个函数必须声明一个生命周期泛型用于标注返回的生命周期, 此泛型独立存在, 不与其他生命周期泛型有关系. 因此返回的引用变量的生命周期完全决定于调用此函数的代码定义. 因为返回引用的生命周期应短于 self 指向的内存块的生命周期, 这只能由调用此函数的代码即程序员来保证, RUST 编译器此时无能为力.

RUST 中, 对于申请的堆内存内存块, 通常将其与一个位于栈内存空间的智能指针的类型变量相结合. 智能指针类型变量生命周期终止时, 调用 drop 方法释放堆内存的内存块. 智能指针类型通常会提供 leak 函数, 将堆内存的内存块与智能指针类型的关联切断. 这通常是一个中间状态, 需要尽快再将堆内存与另一个智能指针类型的变量建立联系, 以便其能重新被纳入生命周期的体系中.

## 小结

本章主要分析了 RUST 标准库内存相关模块, 内存相关模块代码多数不复杂, 主要是要对内存块与类型系统之间的转换要有比较深刻的理解, 并能领会在实际编码过程中在那些场景会使用内存相关的代码和 API. RUST 的内存安全给编码加了非常多的限制, 有些时候这些限制只有通过内存 API 来有效的突破. 如将引用指向的变量所有权转移出来的 take 函数. 后继我们会看到几乎每个标准库的模块都大量的使用了 ptr, mem 模块中的方法和函数. 只要是大型系统, 不熟悉内存模块的代码, 基本上无法做出良好的程序.
